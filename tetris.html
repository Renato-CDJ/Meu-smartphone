<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Tetris</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      margin: 0;
      background: linear-gradient(135deg, #0f1115, #1e222b);
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }

    .iphone {
      width: 390px;
      height: 844px;
      background: #000;
      border-radius: 60px;
      overflow: hidden;
      border: 12px solid #1c1c1c;
      position: relative;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .screen {
      background: linear-gradient(180deg, #12131a, #1e2130);
      border-radius: 48px;
      box-shadow: inset 0 0 40px #0009;
      width: 100%;
      height: 100%;
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .notch {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 210px;
      height: 34px;
      background: black;
      border-bottom-left-radius: 30px;
      border-bottom-right-radius: 30px;
      z-index: 10;
    }

    .game {
      display: grid;
      grid-template-columns: repeat(10, 24px);
      grid-template-rows: repeat(20, 24px);
      gap: 1px;
      background: #1b1f2a;
      border: 2px solid #444;
      position: relative;
    }

    .cell {
      width: 24px;
      height: 24px;
      background: #1e2130;
    }

    .filled {
      background: red;
      border-radius: 4px;
    }

    .score {
      color: white;
      margin-top: 12px;
      font-size: 16px;
    }
  </style>
</head>
<body>
  <div class="iphone">
    <div class="screen">
      <div class="notch"></div>
      <div class="game" id="game"></div>
      <div class="score" id="score">Pontuação: 0</div>
    </div>
  </div>

  <script>
    const COLS = 10;
    const ROWS = 20;
    const game = document.getElementById('game');
    const scoreEl = document.getElementById('score');
    const SHAPES = {
      I: [[1, 1, 1, 1]],
      J: [[1, 0, 0], [1, 1, 1]],
      L: [[0, 0, 1], [1, 1, 1]],
      O: [[1, 1], [1, 1]],
      S: [[0, 1, 1], [1, 1, 0]],
      T: [[0, 1, 0], [1, 1, 1]],
      Z: [[1, 1, 0], [0, 1, 1]]
    };
    const COLORS = {
      I: 'cyan', J: 'blue', L: 'orange', O: 'yellow', S: 'lime', T: 'purple', Z: 'red'
    };

    let grid = [];
    let current = null;
    let interval;
    let score = 0;

    function createGrid() {
      grid = [];
      game.innerHTML = '';
      for (let y = 0; y < ROWS; y++) {
        let row = [];
        for (let x = 0; x < COLS; x++) {
          const cell = document.createElement('div');
          cell.classList.add('cell');
          game.appendChild(cell);
          row.push(cell);
        }
        grid.push(row);
      }
    }

    function spawnPiece() {
      const types = Object.keys(SHAPES);
      const type = types[Math.floor(Math.random() * types.length)];
      current = {
        shape: SHAPES[type],
        color: COLORS[type],
        x: 3,
        y: 0,
        type
      };
      if (!validMove(0, 0)) {
        alert('Fim de jogo!');
        clearInterval(interval);
      } else {
        draw();
      }
    }

    function draw() {
      clear();
      current.shape.forEach((row, dy) => {
        row.forEach((val, dx) => {
          if (val) {
            const x = current.x + dx;
            const y = current.y + dy;
            if (grid[y] && grid[y][x]) {
              grid[y][x].style.background = current.color;
              grid[y][x].classList.add('filled');
            }
          }
        });
      });
    }

    function clear() {
      document.querySelectorAll('.filled:not(.static)').forEach(cell => {
        cell.style.background = '#1e2130';
        cell.classList.remove('filled');
      });
    }

    function move(dx, dy) {
      if (validMove(dx, dy)) {
        current.x += dx;
        current.y += dy;
        draw();
        return true;
      } else if (dy === 1) {
        freeze();
        clearLines();
        spawnPiece();
      }
      return false;
    }

    function rotate() {
      const rotated = current.shape[0].map((_, i) => current.shape.map(row => row[i]).reverse());
      const oldShape = current.shape;
      current.shape = rotated;
      if (!validMove(0, 0)) current.shape = oldShape;
      draw();
    }

    function validMove(dx, dy) {
      return current.shape.every((row, dyIdx) => {
        return row.every((val, dxIdx) => {
          if (!val) return true;
          const x = current.x + dx + dxIdx;
          const y = current.y + dy + dyIdx;
          return x >= 0 && x < COLS && y < ROWS && (!grid[y] || !grid[y][x].classList.contains('static'));
        });
      });
    }

    function freeze() {
      current.shape.forEach((row, dy) => {
        row.forEach((val, dx) => {
          if (val) {
            const x = current.x + dx;
            const y = current.y + dy;
            if (grid[y] && grid[y][x]) {
              grid[y][x].classList.add('static');
            }
          }
        });
      });
    }

    function clearLines() {
      for (let y = ROWS - 1; y >= 0; y--) {
        if (grid[y].every(cell => cell.classList.contains('static'))) {
          for (let yy = y; yy > 0; yy--) {
            for (let x = 0; x < COLS; x++) {
              grid[yy][x].className = grid[yy - 1][x].className;
              grid[yy][x].style.background = grid[yy - 1][x].style.background;
            }
          }
          for (let x = 0; x < COLS; x++) {
            grid[0][x].className = 'cell';
            grid[0][x].style.background = '#1e2130';
          }
          score += 100;
          scoreEl.textContent = `Pontuação: ${score}`;
          y++; // recheck same line
        }
      }
    }

    document.addEventListener('keydown', e => {
      if (e.key === 'ArrowLeft') move(-1, 0);
      else if (e.key === 'ArrowRight') move(1, 0);
      else if (e.key === 'ArrowDown') move(0, 1);
      else if (e.key === 'ArrowUp') rotate();
    });

    createGrid();
    spawnPiece();
    interval = setInterval(() => move(0, 1), 500);
  </script>
</body>
</html>